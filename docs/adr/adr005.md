# ADR 005 – Implémentation du moteur d'appariement et traitement des ordres

## Statut

Acceptée

## Contexte

Nous devons concevoir un système de traitement des ordres qui :

1. **Gère les ordres de manière asynchrone** : Les ordres doivent être traités indépendamment du thread web pour éviter les blocages
2. **Applique des contrôles pré-trade** : Validation du pouvoir d'achat, règles de prix, limites utilisateur
3. **Supporte différents types d'ordres** : Marché vs Limite, différentes durées (DAY/IOC/FOK)
4. **Garantit l'idempotence** : Même clientOrderId ne doit pas créer de doublons
5. **Fournit un horodatage précis** : UTC avec millisecondes pour l'audit et le matching


## Décision

### Architecture du moteur d'appariement

**1. Modèle d'ordre étendu**
```rust
pub struct Order {
    pub order_id: OrderId,           // UUID système
    pub client_order_id: String,     // Pour idempotence
    pub client_id: UserId,
    pub symbol: String,
    pub side: OrderSide,             // Buy/Sell
    pub order_type: OrderType,       // Market/Limit
    pub quantity: u64,
    pub limit_price: Option<f64>,    // Pour ordres limite
    pub time_in_force: TimeInForce,  // DAY/IOC/FOK
    pub status: OrderStatus,
    pub created_at: DateTime<Utc>,   // Horodatage UTC précis
    pub updated_at: DateTime<Utc>,
}
```

**2. Contrôles pré-trade**
- **Service de validation** séparé avec règles configurables
- **Vérifications** : solde suffisant, prix dans les bandes, quantité > 0, instrument actif
- **Limites utilisateur** : taille max par ordre, notional limits
- **Règles de prix** : tick size, circuit breakers

**3. Processus de traitement**
- **Thread séparé** pour le traitement des ordres (pas de blocking du web layer)
- **Queue FIFO** pour maintenir l'ordre d'arrivée des ordres
- **États d'ordre** : Queued → Pending → Filled/PartiallyFilled/Rejected

**4. Persistance et audit**
- Tous les ordres persistés avec horodatage
- Log des changements d'état pour audit
- Support de l'idempotence via `client_order_id`

### Flux de traitement

```
1. Web Handler reçoit l'ordre
2. Validation des données de formulaire
3. Contrôles pré-trade
4. Si OK: Création Order avec status=Queued
5. Ajout à la queue de traitement
6. Thread séparé traite la queue:
   - Queued → Pending (vérifications finales)
   - Pending → Filled/Rejected (simulation matching)
7. Réponse ACK/NACK au client
```

## Conséquences

**Positives :**
- **Séparation des responsabilités** : Web layer découplé du matching engine
- **Performance** : Traitement asynchrone évite les blocages utilisateur
- **Audit et compliance** : Horodatage précis et historique complet
- **Idempotence** : Évite les ordres dupliqués
- **Validation robuste** : Contrôles pré-trade configurables

**Négatives :**
- **Complexité accrue** : Thread supplémentaire à gérer
- **Latence** : Traitement asynchrone peut introduire des délais
- **État partagé** : Synchronisation nécessaire entre threads

**Impact :**
- **Code existant** : Extension de la structure `Order` et `OrderStatus`
- **Tests** : Nouveaux tests pour validation et traitement asynchrone  
- **Configuration** : Paramètres pour les règles de validation
- **Monitoring** : Métriques sur la queue et les temps de traitement
